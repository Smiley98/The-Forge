#line 1 "C:/Users/conno/Desktop/The-Forge/Examples_3/Unit_Tests/src/02_Compute/Shaders/D3D12/compute.comp"
#line 37 "C:/Users/conno/Desktop/The-Forge/Examples_3/Unit_Tests/src/02_Compute/Shaders/D3D12/compute.comp"
RWTexture2D<float4> outputTexture : register(u1);

cbuffer uniformBlock : register(b0,  space1 )
{
	float4x4 mvp;
	float4 c_diffuse;
	float4 c_mu;
	float c_epsilon;
	float zoom;

	int c_width;
	int c_height;
	int c_renderSoftShadows;
}
#line 96 "C:/Users/conno/Desktop/The-Forge/Examples_3/Unit_Tests/src/02_Compute/Shaders/D3D12/compute.comp"
float4 quatMult(float4 q1, float4 q2)
{
	float4 r;

	r.x = q1.x*q2.x - dot(q1.yzw, q2.yzw);
	r.yzw = q1.x*q2.yzw + q2.x*q1.yzw + cross(q1.yzw, q2.yzw);

	return r;
}







float4 quatSq(float4 q)
{
	float4 r;

	r.x = q.x*q.x - dot(q.yzw, q.yzw);
	r.yzw = 2 * q.x*q.yzw;

	return r;
}








float3 normEstimate(float3 p, float4 c)
{
	float3 N;
	float4 qP = float4(p, 0);
	float gradX, gradY, gradZ;

	float4 gx1 = qP - float4( 1e-4 , 0, 0, 0);
	float4 gx2 = qP + float4( 1e-4 , 0, 0, 0);
	float4 gy1 = qP - float4(0,  1e-4 , 0, 0);
	float4 gy2 = qP + float4(0,  1e-4 , 0, 0);
	float4 gz1 = qP - float4(0, 0,  1e-4 , 0);
	float4 gz2 = qP + float4(0, 0,  1e-4 , 0);

	for (int i = 0; i< 10 ; i++)
	{
		gx1 = quatSq(gx1) + c;
		gx2 = quatSq(gx2) + c;
		gy1 = quatSq(gy1) + c;
		gy2 = quatSq(gy2) + c;
		gz1 = quatSq(gz1) + c;
		gz2 = quatSq(gz2) + c;
	}

	gradX = length(gx2) - length(gx1);
	gradY = length(gy2) - length(gy1);
	gradZ = length(gz2) - length(gz1);

	N = normalize(float3(gradX, gradY, gradZ));

	return N;
}
#line 197 "C:/Users/conno/Desktop/The-Forge/Examples_3/Unit_Tests/src/02_Compute/Shaders/D3D12/compute.comp"
float intersectQJulia(inout float3 rO, float3 rD, float4 c, float epsilon)
{
	float dist;



	float rd = 0.0f;
	dist = epsilon;





	while (dist >= epsilon && rd <  3.0 )
	{
		float4 z = float4(rO, 0);


		float4 zp = float4(1, 0, 0, 0);


		float zd = 0.0f;
		uint count = 0;



		while (zd <  10  && count <  10 )
		{
			zp = 2.0f * quatMult(z, zp);
			z = quatSq(z) + c;
			zd = dot(z, z);
			count++;
		}


		float normZ = length(z);
		dist = 0.5f * normZ * log(normZ) / length(zp);

		rO += rD * dist;

		rd = dot(rO, rO);
	}


	return dist;
}









float3 Phong(float3 light, float3 eye, float3 pt, float3 N)
{
	float3 diffuse = float3(1.00, 0.45, 0.25);
	const int specularExponent = 10;
	const float specularity = 0.45;

	float3 L = normalize(light - pt);
	float3 E = normalize(eye - pt);
	float NdotL = dot(N, L);
	float3 R = L - 2 * NdotL * N;

	diffuse = c_diffuse.xyz + abs(N)*0.3;



	return diffuse * max(NdotL, 0) + specularity*pow(max(dot(E, R), 0), specularExponent);
}







float3 intersectSphere(float3 rO, float3 rD)
{
	float B, C, d, t0, t1, t;

	B = 2 * dot(rO, rD);
	C = dot(rO, rO) -  3.0 ;
	d = sqrt(B*B - 4 * C);
	t0 = (-B + d) * 0.5;
	t1 = (-B - d) * 0.5;
	t = min(t0, t1);
	rO += t * rD;

	return rO;
}
#line 311 "C:/Users/conno/Desktop/The-Forge/Examples_3/Unit_Tests/src/02_Compute/Shaders/D3D12/compute.comp"
float4 QJulia(float3 rO,
	float3 rD,

	float4 mu,
	float epsilon,
	float3 eye,
	float3 light,
	bool renderShadows)
{

	const float4 backgroundColor = float4(0.3, 0.3, 0.3, 0);

	float4 color;




	color = backgroundColor;







	rD = normalize(rD);
	rO = intersectSphere(rO, rD);





	float dist = intersectQJulia(rO, rD, mu, epsilon);






	if (dist < epsilon)
	{

		float3 N = normEstimate(rO, mu);


		color.rgb = Phong(light, rD, rO, N);
		color.a = 1;


		if (renderShadows == true)
		{





			float3 L = normalize(light - rO);
			rO += N*epsilon*2.0;
			dist = intersectQJulia(rO, L, mu, epsilon);




			if (dist < epsilon)
				color.rgb *= 0.4;
		}
	}


	return color;
}

[numthreads(16, 16, 1)]
void main(uint3 Gid : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint GI : SV_GroupIndex)
{

	float4 coord = float4((float)DTid.x, (float)DTid.y, 0.0f, 0.0f);


	float2 size = float2((float)c_width, (float)c_height);
	float scale = min(size.x, size.y);
	float2 halfvec = float2(0.5f, 0.5f);
    float2 position = (coord.xy - halfvec * size) / scale *  3.0  * zoom;


	float4 light = float4(1.5f, 0.5f, 4.0f, 0.0f);
	float4 eye = float4(0.0f, 0.0f, 4.0f, 0.0f);
	float4 ray = float4(position.x, position.y, 0.0f, 0.0f);



	light = mul(light, mvp);
	eye = mul(eye, mvp);
	ray = mul(ray, mvp);




	float3 rO = eye.xyz;
	float3 rD = ray.xyz - rO;


	float4 color = QJulia(rO, rD, c_mu, c_epsilon, eye.xyz, light.xyz, c_renderSoftShadows);

    outputTexture[DTid.xy] = color;
}
