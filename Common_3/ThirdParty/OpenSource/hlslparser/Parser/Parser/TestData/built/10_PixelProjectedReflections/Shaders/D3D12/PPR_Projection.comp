cbuffer cbExtendCamera : register(b0, space1)
{
    float4x4 viewMat;
    float4x4 projMat;
    float4x4 viewProjMat;
    float4x4 InvViewProjMat;
    float4 cameraWorldPos;
    float4 viewPortSize;
};

RWStructuredBuffer<uint> IntermediateBuffer : register(u1);
Texture2D<float> DepthTexture : register(t2);
struct PlaneInfo
{
    float4x4 rotMat;
    float4 centerPoint;
    float4 size;
};
cbuffer planeInfoBuffer : register(b3, space1)
{
    PlaneInfo planeInfo[4];
    uint numPlanes;
    uint pad00;
    uint pad01;
    uint pad02;
};

SamplerState defaultSampler : register(s4);
float getDistance(float3 planeNormal, float3 planeCenter, float3 worldPos)
{
    float d = -dot(planeNormal, planeCenter);
    return ((dot(planeNormal, worldPos) + d) / length(planeNormal));
};

bool intersectPlane(in uint index, in float3 worldPos, in float2 fragUV, out float4 reflectedPos)
{
    PlaneInfo thisPlane = planeInfo[index];
    float3 normalVec = thisPlane.rotMat[2].xyz;
    float3 centerPoint = thisPlane.centerPoint.xyz;
    float3 projectedWorldPos = ((float3 )(dot(normalVec, (worldPos - centerPoint))) * normalVec);
    float3 target = (worldPos - ((float3 )(2.0) * projectedWorldPos));
    float dist = getDistance(normalVec, centerPoint, target);
    if (dist >= (float )(0.0))
    {
        return false;
    }
    float3 rO = cameraWorldPos.xyz;
    float3 rD = normalize((target - rO));
    float3 rD_VS = mul((float3x3 )(viewMat), rD);
    if (rD_VS.z < (float )(0.0))
    {
        return false;
    }
    float denom = dot(normalVec, rD);
    if (denom < (float )(0.0))
    {
        float3 p0l0 = (centerPoint - rO);
        float t = (dot(normalVec, p0l0) / denom);
        if (t <= (float )(0.0))
        {
            return false;
        }
        float3 hitPoint = (rO + (rD * (float3 )(t)));
        float3 gap = (hitPoint - centerPoint);
        float xGap = dot(gap, thisPlane.rotMat[0].xyz);
        float yGap = dot(gap, thisPlane.rotMat[1].xyz);
        float width = (thisPlane.size.x * (float )(0.5));
        float height = (thisPlane.size.y * (float )(0.5));
        if (abs(xGap) <= width && (abs(yGap) <= height))
        {
            (reflectedPos = mul(viewProjMat, float4(hitPoint, 1.0)));
            (reflectedPos /= (float4 )(reflectedPos.w));
            (reflectedPos.xy = float2(((reflectedPos.x + (float )(1.0)) * (float )(0.5)), (((float )(1.0) - reflectedPos.y) * (float )(0.5))));
            float depth = DepthTexture.SampleLevel(defaultSampler, reflectedPos.xy, (const float )(0)).r;
            if (depth <= reflectedPos.z)
            {
                return false;
            }
            if (reflectedPos.x < (float )(0.0) || (reflectedPos.y < (float )(0.0)) || (reflectedPos.x > (float )(1.0)) || (reflectedPos.y > (float )(1.0)))
            {
                return false;
            }
            else
            {
                for (uint i = (uint )(0); (i < numPlanes); i++)
                {
                    if (i != index)
                    {
                        PlaneInfo otherPlane = planeInfo[i];
                        float3 otherNormalVec = otherPlane.rotMat[2].xyz;
                        float3 otherCenterPoint = otherPlane.centerPoint.xyz;
                        float innerDenom = dot(otherNormalVec, rD);
                        if (innerDenom < (float )(0.0))
                        {
                            float3 innerP0l0 = (otherCenterPoint - rO);
                            float innerT = (dot(otherNormalVec, innerP0l0) / innerDenom);
                            if (innerT <= (float )(0.0))
                            {
                                continue;
                            }
                            else if ((innerT < t))
                            {
                                float3 innerhitPoint = (rO + (rD * (float3 )(innerT)));
                                float3 innergap = (innerhitPoint - otherCenterPoint);
                                float innerxGap = dot(innergap, otherPlane.rotMat[0].xyz);
                                float inneryGap = dot(innergap, otherPlane.rotMat[1].xyz);
                                float innerWidth = (otherPlane.size.x * (float )(0.5));
                                float innerHeight = (otherPlane.size.y * (float )(0.5));
                                if (abs(innerxGap) <= innerWidth && (abs(inneryGap) <= innerHeight))
                                {
                                    return false;
                                }
                            }
                        }
                    }
                }
                return true;
            }
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
};

float4 getWorldPosition(float2 UV, float depth)
{
    float4 worldPos = mul(InvViewProjMat, float4(((UV.x * (float )(2.0)) - (float )(1.0)), ((((float )(1.0) - UV.y) * (float )(2.0)) - (float )(1.0)), depth, 1.0));
    (worldPos /= (float4 )(worldPos.w));
    return worldPos;
};

uint packInfo(float2 offset)
{
    uint CoordSys = (uint )(0);
    uint YInt = (uint )(0);
    int YFrac = 0;
    int XInt = 0;
    int XFrac = 0;
    if (abs(offset.y) < abs(offset.x))
    {
        if (offset.x < (float )(0.0))
        {
            (YInt = uint(-offset.x));
            (YFrac = int((frac(offset.x) * (float )(8.0))));
            (XInt = int(offset.y));
            (XFrac = int((frac(offset.y) * (float )(8.0))));
            (CoordSys = (uint )(3));
        }
        else
        {
            (YInt = uint(offset.x));
            (YFrac = int((frac(offset.x) * (float )(8.0))));
            (XInt = int(offset.y));
            (XFrac = int((frac(offset.y) * (float )(8.0))));
            (CoordSys = (uint )(1));
        }
    }
    else
    {
        if (offset.y < (float )(0.0))
        {
            (YInt = uint(-offset.y));
            (YFrac = int((frac(offset.y) * (float )(8.0))));
            (XInt = int(offset.x));
            (XFrac = int((frac(offset.x) * (float )(8.0))));
            (CoordSys = (uint )(2));
        }
        else
        {
            (YInt = uint(offset.y));
            (YFrac = int((frac(offset.y) * (float )(8.0))));
            (XInt = int(offset.x));
            (XFrac = int((frac(offset.x) * (float )(8.0))));
            (CoordSys = (uint )(0));
        }
    }
    return ((((((YInt & 4095) << (uint )(20)) | (uint )(YFrac & (int )(7) << 17)) | (uint )(XInt & (int )(4095) << 5)) | (uint )(XFrac & (int )(7) << 2)) | CoordSys);
};

[numthreads(128, 1, 1)]
void main(uint3 Gid : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint GI : SV_GroupIndex)
{
    uint screenWidth = uint(viewPortSize.x);
    uint screenHeight = uint(viewPortSize.y);
    uint indexDX = DTid.x;
    if (indexDX >= (screenWidth * screenHeight))
    {
        return;
    }
    uint indexY = (indexDX / screenWidth);
    uint indexX = (indexDX - (screenWidth * indexY));
    float2 fragUV = float2(((float )(indexX) / viewPortSize.x), ((float )(indexY) / viewPortSize.y));
    float depth = DepthTexture.SampleLevel(defaultSampler, fragUV, (const float )(0)).r;
    if (depth >= (float )(1.0))
    {
        return;
    }
    float4 worldPos = getWorldPosition(fragUV, depth);
    float4 reflectedPos = float4(0.0, 0.0, 0.0, 0.0);
    float2 reflectedUV;
    float2 offset;
    float minDist = (float )(1000000.0);
    for (uint i = (uint )(0); (i < numPlanes); i++)
    {
        if (intersectPlane(i, worldPos.xyz, fragUV, reflectedPos))
        {
            (reflectedUV = float2((reflectedPos.x * viewPortSize.x), (reflectedPos.y * viewPortSize.y)));
            (offset = float2(((fragUV.x - reflectedPos.x) * viewPortSize.x), ((fragUV.y - reflectedPos.y) * viewPortSize.y)));
            uint newIndex = ((uint )(reflectedUV.x) + ((uint )(reflectedUV.y) * screenWidth));
            uint intermediateBufferValue = packInfo(offset);
            InterlockedMin(IntermediateBuffer[newIndex], intermediateBufferValue);
        }
    }
};

