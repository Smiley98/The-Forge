#version 450 core

precision highp float;
precision highp int; 
void sincos1(float x, out float s, out float c) { s = sin(x); c = cos(x); }
void sincos1(vec2 x, out vec2 s, out vec2 c) { s = sin(x); c = cos(x); }
void sincos1(vec3 x, out vec3 s, out vec3 c) { s = sin(x); c = cos(x); }
void sincos1(vec4 x, out vec4 s, out vec4 c) { s = sin(x); c = cos(x); }
mat4 MulMat(mat4 lhs, mat4 rhs)
{
    mat4 dst;
	dst[0][0] = lhs[0][0]*rhs[0][0] + lhs[0][1]*rhs[1][0] + lhs[0][2]*rhs[2][0] + lhs[0][3]*rhs[3][0];
	dst[0][1] = lhs[0][0]*rhs[0][1] + lhs[0][1]*rhs[1][1] + lhs[0][2]*rhs[2][1] + lhs[0][3]*rhs[3][1];
	dst[0][2] = lhs[0][0]*rhs[0][2] + lhs[0][1]*rhs[1][2] + lhs[0][2]*rhs[2][2] + lhs[0][3]*rhs[3][2];
	dst[0][3] = lhs[0][0]*rhs[0][3] + lhs[0][1]*rhs[1][3] + lhs[0][2]*rhs[2][3] + lhs[0][3]*rhs[3][3];
	dst[1][0] = lhs[1][0]*rhs[0][0] + lhs[1][1]*rhs[1][0] + lhs[1][2]*rhs[2][0] + lhs[1][3]*rhs[3][0];
	dst[1][1] = lhs[1][0]*rhs[0][1] + lhs[1][1]*rhs[1][1] + lhs[1][2]*rhs[2][1] + lhs[1][3]*rhs[3][1];
	dst[1][2] = lhs[1][0]*rhs[0][2] + lhs[1][1]*rhs[1][2] + lhs[1][2]*rhs[2][2] + lhs[1][3]*rhs[3][2];
	dst[1][3] = lhs[1][0]*rhs[0][3] + lhs[1][1]*rhs[1][3] + lhs[1][2]*rhs[2][3] + lhs[1][3]*rhs[3][3];
	dst[2][0] = lhs[2][0]*rhs[0][0] + lhs[2][1]*rhs[1][0] + lhs[2][2]*rhs[2][0] + lhs[2][3]*rhs[3][0];
	dst[2][1] = lhs[2][0]*rhs[0][1] + lhs[2][1]*rhs[1][1] + lhs[2][2]*rhs[2][1] + lhs[2][3]*rhs[3][1];
	dst[2][2] = lhs[2][0]*rhs[0][2] + lhs[2][1]*rhs[1][2] + lhs[2][2]*rhs[2][2] + lhs[2][3]*rhs[3][2];
	dst[2][3] = lhs[2][0]*rhs[0][3] + lhs[2][1]*rhs[1][3] + lhs[2][2]*rhs[2][3] + lhs[2][3]*rhs[3][3];
	dst[3][0] = lhs[3][0]*rhs[0][0] + lhs[3][1]*rhs[1][0] + lhs[3][2]*rhs[2][0] + lhs[3][3]*rhs[3][0];
	dst[3][1] = lhs[3][0]*rhs[0][1] + lhs[3][1]*rhs[1][1] + lhs[3][2]*rhs[2][1] + lhs[3][3]*rhs[3][1];
	dst[3][2] = lhs[3][0]*rhs[0][2] + lhs[3][1]*rhs[1][2] + lhs[3][2]*rhs[2][2] + lhs[3][3]*rhs[3][2];
	dst[3][3] = lhs[3][0]*rhs[0][3] + lhs[3][1]*rhs[1][3] + lhs[3][2]*rhs[2][3] + lhs[3][3]*rhs[3][3];
    return dst;
}



layout(row_major, set = 1, binding = 0) uniform uniformBlock
{
    mat4 viewProj;
    vec4 camPos;
    float dt;
    uint startIdx;
    uint endIdx;
    int numLODs;
    int indexOffsets[10];
};

struct AsteroidDynamic
{
    mat4 transform;
    uint indexStart;
    uint indexEnd;
    uint padding[2];
};
struct AsteroidStatic
{
    vec4 rotationAxis;
    vec4 surfaceColor;
    vec4 deepColor;
    float scale;
    float orbitSpeed;
    float rotationSpeed;
    uint textureID;
    uint vertexStart;
    uint padding[3];
};
struct IndirectDrawCommand
{
    uint drawID;
    uint indexCount;
    uint instanceCount;
    uint startIndex;
    int vertexOffset;
    uint startInstance;
    uint padding[2];
};
layout(row_major, set=0, binding=1) buffer asteroidsStatic
{
    AsteroidStatic asteroidsStatic_Data[];
};

layout(row_major, set=0, binding=2) buffer asteroidsDynamic
{
    AsteroidDynamic asteroidsDynamic_Data[];
};

layout(row_major, set=0, binding=3) buffer drawCmds
{
    IndirectDrawCommand drawCmds_Data[];
};

mat4 MakeRotationMatrix(float angle, vec3 axis)
{
    float s, c;
    sincos1((-angle), s, c);
    float x, y, z;
    (x = (axis).x);
    (y = (axis).y);
    (z = (axis).z);
    float xy, yz, zx;
    (xy = ((axis).x * (axis).y));
    (yz = ((axis).y * (axis).z));
    (zx = ((axis).z * (axis).x));
    float oneMinusC = (float(1.0) - c);
    return mat4((((x * x) * oneMinusC) + c), ((xy * oneMinusC) + (z * s)), ((zx * oneMinusC) - (y * s)), 0.0, ((xy * oneMinusC) - (z * s)), (((y * y) * oneMinusC) + c), ((yz * oneMinusC) + (x * s)), 0.0, ((zx * oneMinusC) + (y * s)), ((yz * oneMinusC) - (x * s)), (((z * z) * oneMinusC) + c), 0.0, 0.0, 0.0, 0.0, 1.0);
}
const float minSubdivSizeLog2 = float(log2(0.0019));

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void HLSLmain(uvec3 threadID)
{
    uint asteroidIdx = ((threadID).x + uint(startIdx));
    if((asteroidIdx >= endIdx))
    {
        return;
    }
    AsteroidStatic asteroidStatic = asteroidsStatic_Data[asteroidIdx];
    AsteroidDynamic asteroidDynamic = asteroidsDynamic_Data[asteroidIdx];
    mat4 orbit = MakeRotationMatrix(((asteroidStatic).orbitSpeed * dt), vec3(0.0, 1.0, 0.0));
    mat4 rotate = MakeRotationMatrix(((asteroidStatic).rotationSpeed * dt), ((asteroidStatic).rotationAxis).xyz);
    ((asteroidDynamic).transform = MulMat(MulMat(orbit,(asteroidDynamic).transform),rotate));
    vec3 position = vec3((asteroidDynamic).transform[0][3], (asteroidDynamic).transform[1][3], (asteroidDynamic).transform[2][3]);
    float distToEye = length((position - (camPos).xyz));
    if((distToEye <= float(0)))
    {
        return;
    }
    float relativeScreenSizeLog2 = log2(((asteroidStatic).scale / distToEye));
    float LODfloat = max(float(0.0), (relativeScreenSizeLog2 - minSubdivSizeLog2));
    uint LOD = uint(min((numLODs - 1), int(uint(LODfloat))));
    uint startIdx = uint(indexOffsets[LOD]);
    uint endIdx = uint(indexOffsets[(LOD + uint(1))]);
    ((drawCmds_Data[(threadID).x]).drawID = asteroidIdx);
    ((drawCmds_Data[(threadID).x]).startIndex = startIdx);
    ((drawCmds_Data[(threadID).x]).indexCount = (endIdx - startIdx));
    ((drawCmds_Data[(threadID).x]).vertexOffset = int((asteroidStatic).vertexStart));
    ((drawCmds_Data[(threadID).x]).startInstance = uint(0));
    ((drawCmds_Data[(threadID).x]).instanceCount = uint(1));
    (asteroidsDynamic_Data[asteroidIdx] = asteroidDynamic);
}
void main()
{
    uvec3 threadID;
    threadID = gl_GlobalInvocationID;
    HLSLmain(threadID);
}
