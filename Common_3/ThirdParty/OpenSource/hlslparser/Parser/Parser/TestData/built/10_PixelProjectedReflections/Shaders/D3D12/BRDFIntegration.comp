static float Pi = (static float )(3.14159274);
static float SampleCount = (static float )(128);
float RadicalInverse_VdC(uint bits)
{
    (bits = ((bits << (uint )(16)) | (bits >> (uint )(16))));
    (bits = (((bits & 1431655765) << (uint )(1)) | ((bits & 2863311530) >> (uint )(1))));
    (bits = (((bits & 858993459) << (uint )(2)) | ((bits & 3435973836) >> (uint )(2))));
    (bits = (((bits & 252645135) << (uint )(4)) | ((bits & 4042322160) >> (uint )(4))));
    (bits = (((bits & 16711935) << (uint )(8)) | ((bits & 4278255360) >> (uint )(8))));
    return (float(bits) * 2.328306e-10);
};

float2 Hammersley(uint i, uint N)
{
    return float2((float(i) / float(N)), RadicalInverse_VdC(i));
};

float3 ImportanceSampleGGX(float2 Xi, float3 N, float roughness)
{
    float a = (roughness * roughness);
    float phi = (((float )(2.0) * Pi) * Xi.x);
    float cosTheta = sqrt((((float )(1.0) - Xi.y) / ((float )(1.0) + (((a * a) - (float )(1.0)) * Xi.y))));
    float sinTheta = sqrt(((float )(1.0) - (cosTheta * cosTheta)));
    float3 H;
    (H.x = (cos(phi) * sinTheta));
    (H.y = (sin(phi) * sinTheta));
    (H.z = cosTheta);
    float3 up = (((abs(N.z) < (float )(0.9990000)))?(float3(0.0, 0.0, 1.0)):(float3(1.0, 0.0, 0.0)));
    float3 tangent = normalize(cross(up, N));
    float3 bitangent = cross(N, tangent);
    float3 sampleVec = (((tangent * (float3 )(H.x)) + (bitangent * (float3 )(H.y))) + (N * (float3 )(H.z)));
    return normalize(sampleVec);
};

float GeometrySchlickGGX(float NdotV, float roughness)
{
    float a = roughness;
    float k = ((a * a) / (float )(2.0));
    float nom = NdotV;
    float denom = ((NdotV * ((float )(1.0) - k)) + k);
    return (nom / denom);
};

float GeometrySmith(float3 N, float3 V, float3 L, float roughness)
{
    float NdotV = max(dot(N, V), (const float )(0.0));
    float NdotL = max(dot(N, L), (const float )(0.0));
    float ggx2 = GeometrySchlickGGX(NdotV, roughness);
    float ggx1 = GeometrySchlickGGX(NdotL, roughness);
    return (ggx1 * ggx2);
};

float2 IntegrateBRDF(float NdotV, float roughness)
{
    float3 V;
    (V.x = sqrt(((float )(1.0) - (NdotV * NdotV))));
    (V.y = (float )(0.0));
    (V.z = NdotV);
    float A = (float )(0.0);
    float B = (float )(0.0);
    float3 N = float3(0.0, 0.0, 1.0);
    for (int i = 0; ((float )(i) < SampleCount); ++i)
    {
        float2 Xi = Hammersley((uint )(i), (uint )(SampleCount));
        float3 H = ImportanceSampleGGX(Xi, N, roughness);
        float3 L = normalize((((float3 )((float )(2.0) * dot(V, H)) * H) - V));
        float NdotL = max(L.z, (const float )(0.0));
        float NdotH = max(H.z, (const float )(0.0));
        float VdotH = max(dot(V, H), (const float )(0.0));
        if (NdotL > (float )(0.0))
        {
            float G = GeometrySmith(N, V, L, roughness);
            float G_Vis = ((G * VdotH) / (NdotH * NdotV));
            float Fc = pow(((float )(1.0) - VdotH), (const float )(5.0));
            (A += (((float )(1.0) - Fc) * G_Vis));
            (B += (Fc * G_Vis));
        }
    }
    (A /= float(SampleCount));
    (B /= float(SampleCount));
    return float2(A, B);
};

const static float PI = (const static float )(3.14159274);
RWTexture2D<float2> dstTexture : register(u0);
[numthreads(16, 16, 1)]
void main(uint3 DTid : SV_DispatchThreadID)
{
    float2 texcoords = float2((float(((half )(DTid.x) + 0.5)) / 512.0), ((float )(1.0) - (float(((half )(DTid.y) + 0.5)) / 512.0)));
    float4 output = float4(IntegrateBRDF(texcoords.x, texcoords.y), 0.0, 0.0);
    (dstTexture[DTid.xy] = (float2 )(output));
};

