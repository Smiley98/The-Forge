RWTexture2D<float4> outputTexture : register(u1);
cbuffer uniformBlock : register(b0, space1)
{
    float4x4 mvp;
    float4 c_diffuse;
    float4 c_mu;
    float c_epsilon;
    float zoom;
    int c_width;
    int c_height;
    int c_renderSoftShadows;
};

float4 quatMult(float4 q1, float4 q2)
{
    float4 r;
    (r.x = ((q1.x * q2.x) - dot(q1.yzw, q2.yzw)));
    (r.yzw = ((((float3 )(q1.x) * q2.yzw) + ((float3 )(q2.x) * q1.yzw)) + cross(q1.yzw, q2.yzw)));
    return r;
};

float4 quatSq(float4 q)
{
    float4 r;
    (r.x = ((q.x * q.x) - dot(q.yzw, q.yzw)));
    (r.yzw = ((float3 )((float )(2) * q.x) * q.yzw));
    return r;
};

float3 normEstimate(float3 p, float4 c)
{
    float3 N;
    float4 qP = float4(p, 0);
    float gradX, gradY, gradZ;
    float4 gx1 = (qP - float4(0.00010000000, 0, 0, 0));
    float4 gx2 = (qP + float4(0.00010000000, 0, 0, 0));
    float4 gy1 = (qP - float4(0, 0.00010000000, 0, 0));
    float4 gy2 = (qP + float4(0, 0.00010000000, 0, 0));
    float4 gz1 = (qP - float4(0, 0, 0.00010000000, 0));
    float4 gz2 = (qP + float4(0, 0, 0.00010000000, 0));
    for (int i = 0; (i < 10); i++)
    {
        (gx1 = (quatSq(gx1) + c));
        (gx2 = (quatSq(gx2) + c));
        (gy1 = (quatSq(gy1) + c));
        (gy2 = (quatSq(gy2) + c));
        (gz1 = (quatSq(gz1) + c));
        (gz2 = (quatSq(gz2) + c));
    }
    (gradX = (length(gx2) - length(gx1)));
    (gradY = (length(gy2) - length(gy1)));
    (gradZ = (length(gz2) - length(gz1)));
    (N = normalize(float3(gradX, gradY, gradZ)));
    return N;
};

float intersectQJulia(inout float3 rO, float3 rD, float4 c, float epsilon)
{
    float dist;
    float rd = 0.0;
    (dist = epsilon);
    while (((dist >= epsilon) && (rd < (float )(3.0)))) {
        float4 z = float4(rO, 0);
        float4 zp = float4(1, 0, 0, 0);
        float zd = 0.0;
        uint count = (uint )(0);
        while (((zd < (float )(10)) && (count < (uint )(10)))) {
            (zp = ((float4 )(2.0) * quatMult(z, zp)));
            (z = (quatSq(z) + c));
            (zd = dot(z, z));
            count++;
        }
        float normZ = length(z);
        (dist = (((0.5 * normZ) * log(normZ)) / length(zp)));
        (rO += (rD * (float3 )(dist)));
        (rd = dot(rO, rO));
    }
    return dist;
};

float3 Phong(float3 light, float3 eye, float3 pt, float3 N)
{
    float3 diffuse = float3(1.0, 0.45, 0.25);
    const int specularExponent = 10;
    const float specularity = (const float )(0.45);
    float3 L = normalize((light - pt));
    float3 E = normalize((eye - pt));
    float NdotL = dot(N, L);
    float3 R = (L - ((float3 )((float )(2) * NdotL) * N));
    (diffuse = (c_diffuse.xyz + (abs(N) * (float3 )(0.3))));
    return ((diffuse * (float3 )(max(NdotL, (const float )(0)))) + (float3 )(specularity * pow(max(dot(E, R), (const float )(0)), (const float )(specularExponent))));
};

float3 intersectSphere(float3 rO, float3 rD)
{
    float B, C, d, t0, t1, t;
    (B = ((float )(2) * dot(rO, rD)));
    (C = (dot(rO, rO) - (float )(3.0)));
    (d = sqrt(((B * B) - ((float )(4) * C))));
    (t0 = ((-B + d) * (float )(0.5)));
    (t1 = ((-B - d) * (float )(0.5)));
    (t = min(t0, t1));
    (rO += ((float3 )(t) * rD));
    return rO;
};

float4 QJulia(float3 rO, float3 rD, float4 mu, float epsilon, float3 eye, float3 light, bool renderShadows)
{
    const float4 backgroundColor = float4(0.3, 0.3, 0.3, 0);
    float4 color;
    (color = backgroundColor);
    (rD = normalize(rD));
    (rO = intersectSphere(rO, rD));
    float dist = intersectQJulia(rO, rD, mu, epsilon);
    if (dist < epsilon)
    {
        float3 N = normEstimate(rO, mu);
        (color.rgb = Phong(light, rD, rO, N));
        (color.a = (float )(1));
        if (renderShadows == true)
        {
            float3 L = normalize((light - rO));
            (rO += ((N * (float3 )(epsilon)) * (float3 )(2.0)));
            (dist = intersectQJulia(rO, L, mu, epsilon));
            if (dist < epsilon)
            {
                (color.rgb *= (float3 )(0.4));
            }
        }
    }
    return color;
};

[numthreads(16, 16, 1)]
void main(uint3 Gid : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint GI : SV_GroupIndex)
{
    float4 coord = float4((float )(DTid.x), (float )(DTid.y), 0.0, 0.0);
    float2 size = float2((float )(c_width), (float )(c_height));
    float scale = min(size.x, size.y);
    float2 halfvec = float2(0.5, 0.5);
    float2 position = ((((coord.xy - (halfvec * size)) / (float2 )(scale)) * (float2 )(3.0)) * (float2 )(zoom));
    float4 light = float4(1.5, 0.5, 4.0, 0.0);
    float4 eye = float4(0.0, 0.0, 4.0, 0.0);
    float4 ray = float4(position.x, position.y, 0.0, 0.0);
    (light = mul(light, mvp));
    (eye = mul(eye, mvp));
    (ray = mul(ray, mvp));
    float3 rO = eye.xyz;
    float3 rD = (ray.xyz - rO);
    float4 color = QJulia(rO, rD, c_mu, c_epsilon, eye.xyz, light.xyz, (bool )(c_renderSoftShadows));
    (outputTexture[DTid.xy] = color);
};

