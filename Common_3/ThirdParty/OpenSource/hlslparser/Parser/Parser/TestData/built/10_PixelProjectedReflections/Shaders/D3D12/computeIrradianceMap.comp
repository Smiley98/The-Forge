const static float Pi = (const static float )(3.14159274);
static float SampleDelta = (static float )(0.025);
TextureCube<float4> srcTexture : register(t0);
RWTexture2DArray<float4> dstTexture : register(u2);
SamplerState skyboxSampler : register(s3);
float4 computeIrradiance(float3 N)
{
    float4 irradiance = float4(0.0, 0.0, 0.0, 0.0);
    float3 up = float3(0.0, 1.0, 0.0);
    float3 right = cross(up, N);
    (up = cross(N, right));
    float nrSamples = (float )(0.0);
    for (float phi = (float )(0.0); (phi < ((float )(2.0) * Pi)); (phi += SampleDelta))
    {
        for (float theta = (float )(0.0); (theta < ((float )(0.5) * Pi)); (theta += SampleDelta))
        {
            float3 tangentSample = float3((sin(theta) * cos(phi)), (sin(theta) * sin(phi)), cos(theta));
            float3 sampleVec = ((((float3 )(tangentSample.x) * right) + ((float3 )(tangentSample.y) * up)) + ((float3 )(tangentSample.z) * N));
            float4 sampledValue = srcTexture.SampleLevel(skyboxSampler, sampleVec, (const float )(0));
            (irradiance += float4(((sampledValue.rgb * (float3 )(cos(theta))) * (float3 )(sin(theta))), sampledValue.a));
            nrSamples++;
        }
    }
    return (((float4 )(Pi) * irradiance) * (float4 )((float )(1.0) / float(nrSamples)));
};

[numthreads(16, 16, 1)]
void main(uint3 DTid : SV_DispatchThreadID)
{
    float3 threadPos = (float3 )(DTid);
    uint pixelOffset = (uint )(0);
    for (uint i = (uint )(0); ((float )(i) < threadPos.z); ++i)
    {
        (pixelOffset += (uint )(32 * 32));
    }
    float2 texcoords = float2((float((threadPos.x + (float )(0.5))) / 32.0), (float((threadPos.y + (float )(0.5))) / 32.0));
    float3 sphereDir;
    if (threadPos.z <= (float )(0))
    {
        (sphereDir = normalize(float3(0.5, -(texcoords.y - (float )(0.5)), -(texcoords.x - (float )(0.5)))));
    }
    else if ((threadPos.z <= (float )(1)))
    {
        (sphereDir = normalize(float3(-0.5, -(texcoords.y - (float )(0.5)), (texcoords.x - (float )(0.5)))));
    }
    else if ((threadPos.z <= (float )(2)))
    {
        (sphereDir = normalize(float3((texcoords.x - (float )(0.5)), 0.5, (texcoords.y - (float )(0.5)))));
    }
    else if ((threadPos.z <= (float )(3)))
    {
        (sphereDir = normalize(float3((texcoords.x - (float )(0.5)), -0.5, -(texcoords.y - (float )(0.5)))));
    }
    else if ((threadPos.z <= (float )(4)))
    {
        (sphereDir = normalize(float3((texcoords.x - (float )(0.5)), -(texcoords.y - (float )(0.5)), 0.5)));
    }
    else if ((threadPos.z <= (float )(5)))
    {
        (sphereDir = normalize(float3(-(texcoords.x - (float )(0.5)), -(texcoords.y - (float )(0.5)), -0.5)));
    }
    uint pixelId = (uint )((float )(pixelOffset) + (threadPos.y * (float )(32)) + threadPos.x);
    float4 irradiance = computeIrradiance(sphereDir);
    (dstTexture[int3(threadPos)] = irradiance);
};

