bool RayIntersectsBox(float3 origin, float3 rayDirInv, float3 BboxMin, float3 BboxMax)
{
    const float3 t0 = ((BboxMin - origin) * rayDirInv);
    const float3 t1 = ((BboxMax - origin) * rayDirInv);
    const float3 tmax = max(t0, t1);
    const float3 tmin = min(t0, t1);
    const float a1 = min(tmax.x, min(tmax.y, tmax.z));
    const float a0 = max(max(tmin.x, tmin.y), max(tmin.z, 0.0));
    return (a1 >= a0);
};

bool RayTriangleIntersect(const float3 orig, const float3 dir, float3 v0, float3 e0, float3 e1, inout float t, inout float2 bCoord)
{
    const float3 s1 = cross(dir.xyz, e1);
    const float invd = ((float )(1.0) / dot(s1, e0));
    const float3 d = (orig.xyz - v0);
    (bCoord.x = (dot(d, s1) * invd));
    const float3 s2 = cross(d, e0);
    (bCoord.y = (dot(dir.xyz, s2) * invd));
    (t = (dot(e1, s2) * invd));
    if (bCoord.x < (float )(0.0) || (bCoord.x > (float )(1.0)) || (bCoord.y < (float )(0.0)) || ((bCoord.x + bCoord.y) > (float )(1.0)) || (t < (float )(0.0)) || (t > 1.000000e+09))
    {
        return false;
    }
    else
    {
        return true;
    }
};

bool RayTriangleIntersect(const float3 orig, const float3 dir, float3 v0, float3 e0, float3 e1)
{
    float t = (float )(0);
    float2 bCoord = (float2 )(0);
    return RayTriangleIntersect(orig, dir, v0, e0, e1, t, bCoord);
};

cbuffer cbPerPass : register(b0, space1)
{
    float4x4 projView;
    float4x4 invProjView;
    float4 rtSize;
    float4 lightDir;
    float4 cameraPos;
};

Texture2D<float> depthBuffer : register(t1);
Texture2D<float4> normalBuffer : register(t2);
Buffer<float4> BVHTree : register(t3);
RWTexture2D<float> outputRT : register(u4);
[numthreads(8, 8, 1)]
void main(uint3 Gid : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint GI : SV_GroupIndex)
{
    bool collision = false;
    int offsetToNextNode = 1;
    float depth = depthBuffer[DTid.xy].x;
    float3 normal = normalBuffer[DTid.xy].xyz;
    float NdotL = dot(normal, lightDir.xyz);
    if (depth < (float )(1) && (NdotL > (float )(0)))
    {
        float2 uv = ((float2 )(DTid.xy) * rtSize.zw);
        float4 clipPos = float4((((float2 )(2) * uv) - (float2 )(1)), depth, 1);
        (clipPos.y = -clipPos.y);
        float4 worldPos = mul(invProjView, clipPos);
        (worldPos.xyz /= (float3 )(worldPos.w));
        float3 rayDir = lightDir.xyz;
        float3 rayDirInv = rcp(rayDir);
        (worldPos.xyz += ((float3 )(5) * normal));
        float t = (float )(0);
        float2 bCoord = (float2 )(0);
        int dataOffset = 0;
        bool done = false;
        while ((offsetToNextNode != 0)) {
            float4 element0 = BVHTree[dataOffset++].xyzw;
            float4 element1 = BVHTree[dataOffset++].xyzw;
            (offsetToNextNode = int(element0.w));
            (collision = false);
            if (offsetToNextNode < 0)
            {
                float3 bboxMin = element0.xyz;
                float3 bboxMax = element1.xyz;
                (collision = RayIntersectsBox((float3 )(worldPos), rayDirInv, bboxMin.xyz, bboxMax.xyz));
                if (!collision)
                {
                    (dataOffset += (int )(abs((const float )(offsetToNextNode))));
                }
            }
            else if ((offsetToNextNode > 0))
            {
                float4 element2 = BVHTree[dataOffset++].xyzw;
                float3 vertex0 = element0.xyz;
                float3 vertex1MinusVertex0 = element1.xyz;
                float3 vertex2MinusVertex0 = element2.xyz;
                (collision = RayTriangleIntersect((float3 )(worldPos), rayDir, vertex0.xyz, vertex1MinusVertex0.xyz, vertex2MinusVertex0.xyz, t, bCoord));
                if (collision)
                {
                    break;
                }
            }
        }
    }
    (outputRT[DTid.xy] = ((float )(1) - float(collision)));
};

