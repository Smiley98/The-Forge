#version 450 core

precision highp float;
precision highp int; 
vec3 MulMat(mat3 lhs, vec3 rhs)
{
    vec3 dst;
	dst[0] = lhs[0][0]*rhs[0] + lhs[0][1]*rhs[1] + lhs[0][2]*rhs[2];
	dst[1] = lhs[1][0]*rhs[0] + lhs[1][1]*rhs[1] + lhs[1][2]*rhs[2];
	dst[2] = lhs[2][0]*rhs[0] + lhs[2][1]*rhs[1] + lhs[2][2]*rhs[2];
    return dst;
}

vec4 MulMat(mat4 lhs, vec4 rhs)
{
    vec4 dst;
	dst[0] = lhs[0][0]*rhs[0] + lhs[0][1]*rhs[1] + lhs[0][2]*rhs[2] + lhs[0][3]*rhs[3];
	dst[1] = lhs[1][0]*rhs[0] + lhs[1][1]*rhs[1] + lhs[1][2]*rhs[2] + lhs[1][3]*rhs[3];
	dst[2] = lhs[2][0]*rhs[0] + lhs[2][1]*rhs[1] + lhs[2][2]*rhs[2] + lhs[2][3]*rhs[3];
	dst[3] = lhs[3][0]*rhs[0] + lhs[3][1]*rhs[1] + lhs[3][2]*rhs[2] + lhs[3][3]*rhs[3];
    return dst;
}



layout(row_major, set = 1, binding = 0) uniform cbExtendCamera
{
    mat4 viewMat;
    mat4 projMat;
    mat4 viewProjMat;
    mat4 InvViewProjMat;
    vec4 cameraWorldPos;
    vec4 viewPortSize;
};

layout(row_major, set=0, binding=1) buffer IntermediateBuffer
{
    uint IntermediateBuffer_Data[];
};

layout(set = 0, binding = 2) uniform texture2D DepthTexture;
struct PlaneInfo
{
    mat4 rotMat;
    vec4 centerPoint;
    vec4 size;
};
layout(row_major, set = 1, binding = 3) uniform planeInfoBuffer
{
    PlaneInfo planeInfo[4];
    uint numPlanes;
    uint pad00;
    uint pad01;
    uint pad02;
};

layout(set = 0, binding = 4) uniform sampler defaultSampler;
float getDistance(vec3 planeNormal, vec3 planeCenter, vec3 worldPos)
{
    float d = (-dot(planeNormal, planeCenter));
    return ((dot(planeNormal, worldPos) + d) / length(planeNormal));
}
bool intersectPlane(in uint index, in vec3 worldPos, in vec2 fragUV, out vec4 reflectedPos)
{
    PlaneInfo thisPlane = planeInfo[index];
    vec3 normalVec = ((thisPlane).rotMat[2]).xyz;
    vec3 centerPoint = ((thisPlane).centerPoint).xyz;
    vec3 projectedWorldPos = (vec3(dot(normalVec, (worldPos - centerPoint))) * normalVec);
    vec3 target = (worldPos - (vec3(2.0) * projectedWorldPos));
    float dist = getDistance(normalVec, centerPoint, target);
    if((dist >= float(0.0)))
    {
        return false;
    }
    vec3 rO = (cameraWorldPos).xyz;
    vec3 rD = normalize((target - rO));
    vec3 rD_VS = MulMat(mat3(viewMat),rD);
    if(((rD_VS).z < float(0.0)))
    {
        return false;
    }
    float denom = dot(normalVec, rD);
    if((denom < float(0.0)))
    {
        vec3 p0l0 = (centerPoint - rO);
        float t = (dot(normalVec, p0l0) / denom);
        if((t <= float(0.0)))
        {
            return false;
        }
        vec3 hitPoint = (rO + (rD * vec3(t)));
        vec3 gap = (hitPoint - centerPoint);
        float xGap = dot(gap, ((thisPlane).rotMat[0]).xyz);
        float yGap = dot(gap, ((thisPlane).rotMat[1]).xyz);
        float width = (((thisPlane).size).x * float(0.5));
        float height = (((thisPlane).size).y * float(0.5));
        if(((abs(xGap) <= width) && (abs(yGap) <= height)))
        {
            (reflectedPos = MulMat(viewProjMat,vec4(hitPoint, 1.0)));
            (reflectedPos /= vec4((reflectedPos).w));
            ((reflectedPos).xy = vec2((((reflectedPos).x + float(1.0)) * float(0.5)), ((float(1.0) - (reflectedPos).y) * float(0.5))));
            float depth = (textureLod(sampler2D(DepthTexture, defaultSampler), (reflectedPos).xy, float(0))).r;
            if((depth <= (reflectedPos).z))
            {
                return false;
            }
            if((((((reflectedPos).x < float(0.0)) || ((reflectedPos).y < float(0.0))) || ((reflectedPos).x > float(1.0))) || ((reflectedPos).y > float(1.0))))
            {
                return false;
            }
            else
            {
                for (uint i = uint(0); (i < numPlanes); (i++))
                {
                    if((i != index))
                    {
                        PlaneInfo otherPlane = planeInfo[i];
                        vec3 otherNormalVec = ((otherPlane).rotMat[2]).xyz;
                        vec3 otherCenterPoint = ((otherPlane).centerPoint).xyz;
                        float innerDenom = dot(otherNormalVec, rD);
                        if((innerDenom < float(0.0)))
                        {
                            vec3 innerP0l0 = (otherCenterPoint - rO);
                            float innerT = (dot(otherNormalVec, innerP0l0) / innerDenom);
                            if((innerT <= float(0.0)))
                            {
                                continue;
                            }
                            else if ((innerT < t))
                            {
                                vec3 innerhitPoint = (rO + (rD * vec3(innerT)));
                                vec3 innergap = (innerhitPoint - otherCenterPoint);
                                float innerxGap = dot(innergap, ((otherPlane).rotMat[0]).xyz);
                                float inneryGap = dot(innergap, ((otherPlane).rotMat[1]).xyz);
                                float innerWidth = (((otherPlane).size).x * float(0.5));
                                float innerHeight = (((otherPlane).size).y * float(0.5));
                                if(((abs(innerxGap) <= innerWidth) && (abs(inneryGap) <= innerHeight)))
                                {
                                    return false;
                                }
                            }
                        }
                    }
                }
                return true;
            }
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
}
vec4 getWorldPosition(vec2 UV, float depth)
{
    vec4 worldPos = MulMat(InvViewProjMat,vec4((((UV).x * float(2.0)) - float(1.0)), (((float(1.0) - (UV).y) * float(2.0)) - float(1.0)), depth, 1.0));
    (worldPos /= vec4((worldPos).w));
    return worldPos;
}
uint packInfo(vec2 offset)
{
    uint CoordSys = uint(0);
    uint YInt = uint(0);
    int YFrac = 0;
    int XInt = 0;
    int XFrac = 0;
    if((abs((offset).y) < abs((offset).x)))
    {
        if(((offset).x < float(0.0)))
        {
            (YInt = uint((-(offset).x)));
            (YFrac = int((fract((offset).x) * float(8.0))));
            (XInt = int((offset).y));
            (XFrac = int((fract((offset).y) * float(8.0))));
            (CoordSys = uint(3));
        }
        else
        {
            (YInt = uint((offset).x));
            (YFrac = int((fract((offset).x) * float(8.0))));
            (XInt = int((offset).y));
            (XFrac = int((fract((offset).y) * float(8.0))));
            (CoordSys = uint(1));
        }
    }
    else
    {
        if(((offset).y < float(0.0)))
        {
            (YInt = uint((-(offset).y)));
            (YFrac = int((fract((offset).y) * float(8.0))));
            (XInt = int((offset).x));
            (XFrac = int((fract((offset).x) * float(8.0))));
            (CoordSys = uint(2));
        }
        else
        {
            (YInt = uint((offset).y));
            (YFrac = int((fract((offset).y) * float(8.0))));
            (XInt = int((offset).x));
            (XFrac = int((fract((offset).x) * float(8.0))));
            (CoordSys = uint(0));
        }
    }
    return ((((((YInt & 4095u) << uint(20)) | uint(((YFrac & int(7u)) << 17))) | uint(((XInt & int(4095u)) << 5))) | uint(((XFrac & int(7u)) << 2))) | CoordSys);
}

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
void HLSLmain(uvec3 Gid, uvec3 DTid, uvec3 GTid, uint GI)
{
    uint screenWidth = uint((viewPortSize).x);
    uint screenHeight = uint((viewPortSize).y);
    uint indexDX = (DTid).x;
    if((indexDX >= (screenWidth * screenHeight)))
    {
        return;
    }
    uint indexY = (indexDX / screenWidth);
    uint indexX = (indexDX - (screenWidth * indexY));
    vec2 fragUV = vec2((float(indexX) / (viewPortSize).x), (float(indexY) / (viewPortSize).y));
    float depth = (textureLod(sampler2D(DepthTexture, defaultSampler), fragUV, float(0))).r;
    if((depth >= float(1.0)))
    {
        return;
    }
    vec4 worldPos = getWorldPosition(fragUV, depth);
    vec4 reflectedPos = vec4(0.0, 0.0, 0.0, 0.0);
    vec2 reflectedUV;
    vec2 offset;
    float minDist = float(1000000.0);
    for (uint i = uint(0); (i < numPlanes); (i++))
    {
        if(intersectPlane(i, (worldPos).xyz, fragUV, reflectedPos))
        {
            (reflectedUV = vec2(((reflectedPos).x * (viewPortSize).x), ((reflectedPos).y * (viewPortSize).y)));
            (offset = vec2((((fragUV).x - (reflectedPos).x) * (viewPortSize).x), (((fragUV).y - (reflectedPos).y) * (viewPortSize).y)));
            uint newIndex = (uint((reflectedUV).x) + (uint((reflectedUV).y) * screenWidth));
            uint intermediateBufferValue = packInfo(offset);
            ;
        }
    }
}
void main()
{
    uvec3 Gid;
    Gid = gl_WorkGroupID;
    uvec3 DTid;
    DTid = gl_GlobalInvocationID;
    uvec3 GTid;
    GTid = gl_LocalInvocationID;
    uint GI;
    GI = gl_LocalInvocationIndex;
    HLSLmain(Gid, DTid, GTid, GI);
}
