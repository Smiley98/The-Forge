static float Pi = (static float )(3.14159274);
static int SampleCount = 128;
struct PrecomputeSkySpecularData
{
    uint mipSize;
    float roughness;
};
ConstantBuffer<PrecomputeSkySpecularData> RootConstant : register(b0);
TextureCube<float4> srcTexture : register(t1);
RWTexture2DArray<float4> dstTexture : register(u2, space3);
SamplerState skyboxSampler : register(s3);
float RadicalInverse_VdC(uint bits)
{
    (bits = ((bits << (uint )(16)) | (bits >> (uint )(16))));
    (bits = (((bits & 1431655765) << (uint )(1)) | ((bits & 2863311530) >> (uint )(1))));
    (bits = (((bits & 858993459) << (uint )(2)) | ((bits & 3435973836) >> (uint )(2))));
    (bits = (((bits & 252645135) << (uint )(4)) | ((bits & 4042322160) >> (uint )(4))));
    (bits = (((bits & 16711935) << (uint )(8)) | ((bits & 4278255360) >> (uint )(8))));
    return (float(bits) * 2.328306e-10);
};

float2 Hammersley(uint i, uint N)
{
    return float2((float(i) / float(N)), RadicalInverse_VdC(i));
};

float DistributionGGX(float3 N, float3 H, float roughness)
{
    float a = (roughness * roughness);
    float a2 = (a * a);
    float NdotH = max(dot(N, H), (const float )(0.0));
    float NdotH2 = (NdotH * NdotH);
    float nom = a2;
    float denom = ((NdotH2 * (a2 - (float )(1.0))) + (float )(1.0));
    (denom = ((Pi * denom) * denom));
    return (nom / denom);
};

float3 ImportanceSampleGGX(float2 Xi, float3 N, float roughness)
{
    float a = (roughness * roughness);
    float phi = (((float )(2.0) * Pi) * Xi.x);
    float cosTheta = sqrt((((float )(1.0) - Xi.y) / ((float )(1.0) + (((a * a) - (float )(1.0)) * Xi.y))));
    float sinTheta = sqrt(((float )(1.0) - (cosTheta * cosTheta)));
    float3 H;
    (H.x = (cos(phi) * sinTheta));
    (H.y = (sin(phi) * sinTheta));
    (H.z = cosTheta);
    float3 up = (((abs(N.z) < (float )(0.9990000)))?(float3(0.0, 0.0, 1.0)):(float3(1.0, 0.0, 0.0)));
    float3 tangent = normalize(cross(up, N));
    float3 bitangent = cross(N, tangent);
    float3 sampleVec = (((tangent * (float3 )(H.x)) + (bitangent * (float3 )(H.y))) + (N * (float3 )(H.z)));
    return normalize(sampleVec);
};

[numthreads(16, 16, 1)]
void main(uint3 DTid : SV_DispatchThreadID)
{
    uint3 threadPos = DTid;
    float mipRoughness = RootConstant.roughness;
    uint mipSize = RootConstant.mipSize;
    if (threadPos.x >= mipSize || (threadPos.y >= mipSize))
    {
        return;
    }
    float2 texcoords = float2((float(((half )(threadPos.x) + 0.5)) / (float )(mipSize)), (float(((half )(threadPos.y) + 0.5)) / (float )(mipSize)));
    float3 sphereDir;
    if (threadPos.z <= (uint )(0))
    {
        (sphereDir = normalize(float3(0.5, -(texcoords.y - (float )(0.5)), -(texcoords.x - (float )(0.5)))));
    }
    else if ((threadPos.z <= (uint )(1)))
    {
        (sphereDir = normalize(float3(-0.5, -(texcoords.y - (float )(0.5)), (texcoords.x - (float )(0.5)))));
    }
    else if ((threadPos.z <= (uint )(2)))
    {
        (sphereDir = normalize(float3((texcoords.x - (float )(0.5)), 0.5, (texcoords.y - (float )(0.5)))));
    }
    else if ((threadPos.z <= (uint )(3)))
    {
        (sphereDir = normalize(float3((texcoords.x - (float )(0.5)), -0.5, -(texcoords.y - (float )(0.5)))));
    }
    else if ((threadPos.z <= (uint )(4)))
    {
        (sphereDir = normalize(float3((texcoords.x - (float )(0.5)), -(texcoords.y - (float )(0.5)), 0.5)));
    }
    else if ((threadPos.z <= (uint )(5)))
    {
        (sphereDir = normalize(float3(-(texcoords.x - (float )(0.5)), -(texcoords.y - (float )(0.5)), -0.5)));
    }
    float3 N = sphereDir;
    float3 R = N;
    float3 V = R;
    float totalWeight = (float )(0.0);
    float4 prefilteredColor = float4(0.0, 0.0, 0.0, 0.0);
    for (int i = 0; (i < SampleCount); ++i)
    {
        float2 Xi = Hammersley((uint )(i), (uint )(SampleCount));
        float3 H = ImportanceSampleGGX(Xi, N, mipRoughness);
        float3 L = normalize((((float3 )((float )(2.0) * dot(V, H)) * H) - V));
        float NdotL = max(dot(N, L), (const float )(0.0));
        if (NdotL > (float )(0.0))
        {
            float D = DistributionGGX(N, H, mipRoughness);
            float NdotH = max(dot(N, H), (const float )(0.0));
            float HdotV = max(dot(H, V), (const float )(0.0));
            float pdf = (((D * NdotH) / ((float )(4.0) * HdotV)) + (float )(0.00010000000));
            float saTexel = (((float )(4.0) * Pi) / (float )(6.0 * (half )(mipSize) * (half )(mipSize)));
            float saSample = ((float )(1.0) / ((float(SampleCount) * pdf) + (float )(0.00010000000)));
            float mipLevel = (float )(((mipRoughness == (float )(0.0))?(0.0):((float )(0.5) * log2((saSample / saTexel)))));
            (prefilteredColor += (srcTexture.SampleLevel(skyboxSampler, L, mipLevel) * (float4 )(NdotL)));
            (totalWeight += NdotL);
        }
    }
    (prefilteredColor = (prefilteredColor / (float4 )(totalWeight)));
    (dstTexture[threadPos] = prefilteredColor);
};

