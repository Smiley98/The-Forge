#line 1 "C:/Users/conno/Desktop/The-Forge/Examples_3/Unit_Tests/src/09a_HybridRaytracing/Shaders/D3D12/raytracedShadowsPass.comp"
#line 26 "C:/Users/conno/Desktop/The-Forge/Examples_3/Unit_Tests/src/09a_HybridRaytracing/Shaders/D3D12/raytracedShadowsPass.comp"
#line 1 "raytracingCommon.h"






bool RayIntersectsBox(float3 origin, float3 rayDirInv, float3 BboxMin, float3 BboxMax)
{
	const float3 t0 = (BboxMin - origin) * rayDirInv;
	const float3 t1 = (BboxMax - origin) * rayDirInv;

	const float3 tmax = max(t0, t1);
	const float3 tmin = min(t0, t1);

	const float a1 = min(tmax.x, min(tmax.y, tmax.z));
	const float a0 = max( max(tmin.x,tmin.y), max(tmin.z, 0.0f) );

	return a1 >= a0;
}


bool RayTriangleIntersect(
	const float3 orig,
	const float3 dir,
	float3 v0,
	float3 e0,
	float3 e1,
	inout float t,
	inout float2 bCoord)
{
	const float3 s1 = cross(dir.xyz, e1);
	const float invd = 1.0 / (dot(s1, e0));
	const float3 d = orig.xyz - v0;
	bCoord.x = dot(d, s1) * invd;
	const float3 s2 = cross(d, e0);
	bCoord.y = dot(dir.xyz, s2) * invd;
	t = dot(e1, s2) * invd;

	if (
#line 43 "raytracingCommon.h"
		bCoord.x < 0.0 || bCoord.x > 1.0 || bCoord.y < 0.0 || (bCoord.x + bCoord.y) > 1.0 || t < 0.0 || t > 1e9)
	{
		return false;
	}
	else
	{
		return true;
	}
}

bool RayTriangleIntersect(
	const float3 orig,
	const float3 dir,
	float3 v0,
	float3 e0,
	float3 e1)
{
	float t = 0;
	float2 bCoord = 0;
	return RayTriangleIntersect(orig, dir, v0, e0, e1, t, bCoord);
}
#line 27 "C:/Users/conno/Desktop/The-Forge/Examples_3/Unit_Tests/src/09a_HybridRaytracing/Shaders/D3D12/raytracedShadowsPass.comp"

cbuffer cbPerPass : register(b0,  space1 )
{
	float4x4 projView;
	float4x4 invProjView;
	float4 rtSize;
	float4 lightDir;
	float4 cameraPos;
}

Texture2D<float> depthBuffer : register(t1);
Texture2D<float4> normalBuffer : register(t2);
Buffer<float4> BVHTree : register(t3);

RWTexture2D<float> outputRT : register(u4);





[numthreads( 8 ,  8 , 1)]
void main(uint3 Gid : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint GI : SV_GroupIndex)
{
	bool collision = false;
	int offsetToNextNode = 1;

	float depth = depthBuffer[DTid.xy].x;
	float3 normal = normalBuffer[DTid.xy].xyz;

	float NdotL = dot(normal, lightDir.xyz);


	if (depth < 1 && NdotL > 0)
	{
		float2 uv = DTid.xy * rtSize.zw;


		float4 clipPos = float4(2 * uv - 1, depth, 1);
		clipPos.y = -clipPos.y;

		float4 worldPos = mul(invProjView, clipPos);
		worldPos.xyz /= worldPos.w;

		float3 rayDir = lightDir.xyz;
		float3 rayDirInv = rcp(rayDir);


		worldPos.xyz += 5 * normal;

		float t = 0;
		float2 bCoord = 0;

		int dataOffset = 0;
		bool done = false;

		[loop]
		while (offsetToNextNode != 0)
		{
			float4 element0 = BVHTree[dataOffset++].xyzw;
			float4 element1 = BVHTree[dataOffset++].xyzw;

			offsetToNextNode = int(element0.w);

			collision = false;

			if (offsetToNextNode < 0)
			{

				float3 bboxMin = element0.xyz;
				float3 bboxMax = element1.xyz;


				collision = RayIntersectsBox(worldPos, rayDirInv, bboxMin.xyz, bboxMax.xyz);


				if (!collision)
					dataOffset += abs(offsetToNextNode);
			}
			else if (offsetToNextNode > 0)
			{
				float4 element2 = BVHTree[dataOffset++].xyzw;

				float3 vertex0 = element0.xyz;
				float3 vertex1MinusVertex0 = element1.xyz;
				float3 vertex2MinusVertex0 = element2.xyz;


				collision = RayTriangleIntersect(worldPos, rayDir, vertex0.xyz, vertex1MinusVertex0.xyz, vertex2MinusVertex0.xyz, t, bCoord);

				if (collision)
				{
					break;
				}
			}

		};
	}

	outputRT[DTid.xy] = 1 - float(collision);
}
