#line 1 "C:/Users/conno/Desktop/The-Forge/Examples_3/Unit_Tests/src/15_Transparency/Shaders/D3D12/phenomenologicalTransparency.frag"
#line 25 "C:/Users/conno/Desktop/The-Forge/Examples_3/Unit_Tests/src/15_Transparency/Shaders/D3D12/phenomenologicalTransparency.frag"
#line 1 "shading.h"
#line 27 "shading.h"
#line 1 "shaderDefs.h"
#line 22 "shaderDefs.h"
struct Material
{
	float4 Color;
	float4 Transmission;
	float RefractionRatio;
	float Collimation;
	float2 Padding;
	uint TextureFlags;
	uint AlbedoTexID;
	uint MetallicTexID;
	uint RoughnessTexID;
	uint EmissiveTexID;
	uint3 Padding2;
};

struct ObjectInfo
{
	float4x4 toWorld;
	float4x4 normalMat;
	uint matID;
};

cbuffer DrawInfoRootConstant :  register(b0, space0 )
{
	uint baseInstance = 0;
};

cbuffer ObjectUniformBlock :  register(b0, space1 )
{
	ObjectInfo objectInfo[ 128 ];
};

cbuffer LightUniformBlock :  register(b3, space1 )
{
	float4x4 lightViewProj;
	float4 lightDirection;
	float4 lightColor;
};

cbuffer CameraUniform :  register(b1, space1 )
{
	float4x4 camViewProj;
	float4x4 camViewMat;
	float4 camClipInfo;
	float4 camPosition;
};

cbuffer MaterialUniform :  register(b2, space1 )
{
	Material Materials[ 128 ];
};

Texture2D MaterialTextures[ 8 ] :  register(t100, space0 ) ;
SamplerState LinearSampler :  register(s0, space0 ) ;

Texture2D VSM :  register(t1, space0 ) ;
SamplerState VSMSampler :  register(s2, space0 ) ;
#line 28 "shading.h"
#line 30 "shading.h"
#line 1 "varianceShadowMapping.h"
#line 28 "varianceShadowMapping.h"
#line 1 "shaderDefs.h"
#line 29 "varianceShadowMapping.h"

float2 ComputeMoments(float depth)
{
	float2 moments;
	moments.x = depth;
	float2 pd = float2(ddx(depth), ddy(depth));
	moments.y = depth * depth + 0.25f * dot(pd, pd);
	return moments;
}

float ChebyshevUpperBound(float2 moments, float t)
{
	float p = t <= moments.x;
	float variance = moments.y - (moments.x * moments.x);
	variance = max(variance, 0.001f);
	float d = t - moments.x;
	float pMax = variance / (variance + d * d);
	return max(p, pMax);
}

float3 ShadowContribution(float2 shadowMapPos, float distanceToLight)
{
	float2 moments = VSM.Sample(VSMSampler, shadowMapPos).xy;
	float3 shadow = ChebyshevUpperBound(moments, distanceToLight);
#line 63 "varianceShadowMapping.h"
	return shadow;
}
#line 31 "shading.h"


float4 Shade(uint matID, float2 uv, float3 worldPos, float3 normal)
{
	float nDotl = dot(normal, -lightDirection.xyz);
	Material mat = Materials[matID];
	float4 matColor = mat.TextureFlags & 1 ? MaterialTextures[mat.AlbedoTexID].Sample(LinearSampler, uv) : mat.Color;
	float3 viewVec = normalize(worldPos - camPosition.xyz);
	if (nDotl < 0.05f)
		nDotl = 0.05f;
	float3 diffuse = lightColor.xyz * matColor.xyz * nDotl;
	float3 specular = lightColor.xyz * pow(saturate(dot(reflect(-lightDirection.xyz, normal), viewVec)),  10.0f );
	float3 finalColor = saturate(diffuse + specular * 0.5f);


	float4 shadowMapPos = mul(lightViewProj, float4(worldPos, 1.0f));
	shadowMapPos.y = -shadowMapPos.y;
	shadowMapPos.xy = (shadowMapPos.xy + 1.0f) * 0.5f;
	if (clamp(shadowMapPos.x, 0.01f, 0.99f) == shadowMapPos.x &&
		clamp(shadowMapPos.y, 0.01f, 0.99f) == shadowMapPos.y &&
		shadowMapPos.z > 0.0f)
	{
		float3 lighting = ShadowContribution(shadowMapPos.xy, shadowMapPos.z);
		finalColor *= lighting;
	}


	return float4(finalColor, matColor.a);
}
#line 26 "C:/Users/conno/Desktop/The-Forge/Examples_3/Unit_Tests/src/15_Transparency/Shaders/D3D12/phenomenologicalTransparency.frag"

struct VSOutput
{
	float4 Position : SV_POSITION;
	float4 WorldPosition : POSITION0;
	float4 Normal : NORMAL0;
	float4 UV : TEXCOORD0;
	uint MatID : MAT_ID;
#line 40 "C:/Users/conno/Desktop/The-Forge/Examples_3/Unit_Tests/src/15_Transparency/Shaders/D3D12/phenomenologicalTransparency.frag"
};

struct PSOutput
{
	float4 Accumulation : SV_Target0;
	float4 Modulation : SV_Target1;
#line 49 "C:/Users/conno/Desktop/The-Forge/Examples_3/Unit_Tests/src/15_Transparency/Shaders/D3D12/phenomenologicalTransparency.frag"
};
#line 56 "C:/Users/conno/Desktop/The-Forge/Examples_3/Unit_Tests/src/15_Transparency/Shaders/D3D12/phenomenologicalTransparency.frag"
float WeightFunction(float alpha, float depth)
{
	float tmp = 1.0f - depth * 0.99f;
	tmp *= tmp * tmp * 1e4f;
	return clamp(alpha * tmp, 1e-3f, 1.5e2);
}

float2 ComputeRefractionOffset(float3 csNormal, float3 csPosition, float eta)
{
	const float2 backSizeInMeters = 1000.0f * (1.0f / ((1.0f - eta) * 100.0f));

	const float backgroundZ = csPosition.z - 4.0f;

	float3 dir = normalize(csPosition);
	float3 refracted = refract(dir, csNormal, eta);

	bool totalInternalRefraction = dot(refracted, refracted) < 0.01f;
	if (totalInternalRefraction)
		return 0.0f;
	else
	{
		float3 plane = csPosition;
		plane.z -= backgroundZ;

		float2 hit = (plane.xy - refracted.xy * plane.z / refracted.z);
		float2 backCoord = (hit / backSizeInMeters) + 0.5f;
		float2 startCoord = (csPosition.xy / backSizeInMeters) + 0.5f;
		return backCoord - startCoord;
	}
}

PSOutput main(VSOutput input)
{
	PSOutput output;

	float3 transmission = Materials[input.MatID].Transmission.xyz;
	float collimation = Materials[input.MatID].Collimation;
	float4 finalColor = Shade(input.MatID, input.UV.xy, input.WorldPosition.xyz, normalize(input.Normal.xyz));

	float d = input.Position.z / input.Position.w;
	float4 premultipliedColor = float4(finalColor.rgb * finalColor.a, finalColor.a);
	float coverage = finalColor.a;

	output.Modulation.rgb = coverage * (1.0f - transmission);
	coverage *= 1.0f - (transmission.r + transmission.g + transmission.b) * (1.0f / 3.0f);

	float w = WeightFunction(coverage, d);
	output.Accumulation = float4(premultipliedColor.rgb, coverage) * w;
#line 121 "C:/Users/conno/Desktop/The-Forge/Examples_3/Unit_Tests/src/15_Transparency/Shaders/D3D12/phenomenologicalTransparency.frag"
	output.Modulation.a = 0.0f;
#line 133 "C:/Users/conno/Desktop/The-Forge/Examples_3/Unit_Tests/src/15_Transparency/Shaders/D3D12/phenomenologicalTransparency.frag"
	return output;
}
